# BAEKJOON 알고리즘 문제 풀이
## 2161번 : 카드 1
### 문제
N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.

이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.

예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나면, 버린 카드들은 순서대로 1 3 2가 되고, 남는 카드는 4가 된다.

N이 주어졌을 때, 버린 카드들을 순서대로 출력하고, 마지막에 남게 되는 카드를 출력하는 프로그램을 작성하시오.

### 입력
첫째 줄에 정수 N(1 ≤ N ≤ 1,000)이 주어진다.

### 출력
첫째 줄에 버리는 카드들을 순서대로 출력한다. 제일 마지막에는 남게 되는 카드의 번호를 출력한다.

```python
# N장의 카드
# 제일 위: 1번 카드 / 제일 아래: N번 카드
# 1. 제일 위의 카드 버림 (popleft)
# 2.그 다음 위에 있는 카드를 제일 아래로 옮김 (append)
# 버린 카드를 순서대로 출력 (throw)
# 마지막에 남는 카드 출력 (final_left)

from collections import deque

N = int(input())

q = deque(range(1, N + 1)) # 카드는 1번부터니까

throw = [] # 버린 카드를 저장할 리스트

# 카드가 1장 남을 때까지 반복
while len(q) > 1:
    # 1) 제일 위 카드 버리고
    pop_el = q.popleft() 
    throw.append(pop_el) # throw 리스트에 버린 카드 추가
    
    # 2) 그 다음 카드 아래로 옮기기
    move = q.popleft()
    q.append(move)

last = q.popleft()
print(*throw, last) # *은 리스트의 요소 하나씩 풀어서 전달
```
## 1158번 : 요세푸스 문제
### 문제
요세푸스 문제는 다음과 같다.

1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 <3, 6, 2, 7, 5, 1, 4>이다.

N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.

### 입력
첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 5,000)

### 출력
예제와 같이 요세푸스 순열을 출력한다.

```python
# 1번부터 N번까지 N명의 사람이 원을 그리며 앉아있음
# 순서대로 K번째 사람 제거
# 남은 사람들로 다시 원을 만들고 N명의 사람이 모두 제거될 때까지 반복
# While문 사용.

from collections import deque

N, K = map(int, input().split())

q = deque(range(1, N + 1))
result = []

while q: # while len(q) > 0:/  비어 있으면 False  안 비어 있으면 True
    for _ in range(K - 1): # K번째 앞 사람들을 뒤로 이동
        q.append(q.popleft())
    
    result.append(q.popleft()) # 그리고 맨 앞사람이 된 K번째 사람을 제거
print("<" + ", ".join(map(str, result)) + ">")
```

## 9012번 : 괄호
### 문제
괄호 문자열(Parenthesis String, PS)은 두 개의 괄호 기호인 ‘(’ 와 ‘)’ 만으로 구성되어 있는 문자열이다. 그 중에서 괄호의 모양이 바르게 구성된 문자열을 올바른 괄호 문자열(Valid PS, VPS)이라고 부른다. 한 쌍의 괄호 기호로 된 “( )” 문자열은 기본 VPS 이라고 부른다. 만일 x 가 VPS 라면 이것을 하나의 괄호에 넣은 새로운 문자열 “(x)”도 VPS 가 된다. 그리고 두 VPS x 와 y를 접합(concatenation)시킨 새로운 문자열 xy도 VPS 가 된다. 예를 들어 “(())()”와 “((()))” 는 VPS 이지만 “(()(”, “(())()))” , 그리고 “(()” 는 모두 VPS 가 아닌 문자열이다. 
여러분은 입력으로 주어진 괄호 문자열이 VPS 인지 아닌지를 판단해서 그 결과를 YES 와 NO 로 나타내어야 한다. 

### 입력
입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 주어진다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터의 첫째 줄에는 괄호 문자열이 한 줄에 주어진다. 하나의 괄호 문자열의 길이는 2 이상 50 이하이다. 

### 출력
출력은 표준 출력을 사용한다. 만일 입력 괄호 문자열이 올바른 괄호 문자열(VPS)이면 “YES”, 아니면 “NO”를 한 줄에 하나씩 차례대로 출력해야 한다. 

```python
T = int(input())
for _ in range(T):
    s = input().strip() # 문자열 한 줄을 입력받아라
    # strip()은 입력 문자열 양 끝의 쓸데없는 공백/엔터를 제거
    count = 0

    for ch in s:
        if ch == '(':
            count += 1
        else:
            count -= 1
        if count < 0:
            print("NO")
            break
    else:
         if count == 0:
             print("YES")
         else:
             print("NO")
```
